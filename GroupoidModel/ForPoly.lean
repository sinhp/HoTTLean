import Poly.UvPoly.Basic
import GroupoidModel.ForMathlib

open CategoryTheory Limits

noncomputable section

namespace CategoryTheory.UvPoly

variable {ùíû} [Category ùíû] [HasTerminal ùíû] [HasPullbacks ùíû]

variable {E B : ùíû} (P : UvPoly E B) (A : ùíû)

def compDomEquiv {Œì E B D A : ùíû} {P : UvPoly E B} {Q : UvPoly D A} :
    (Œì ‚ü∂ compDom P Q) ‚âÉ
      (AB : Œì ‚ü∂ P.functor.obj A) √ó (Œ± : Œì ‚ü∂ E) √ó (Œ≤ : Œì ‚ü∂ D) √ó'
      (w : AB ‚â´ P.fstProj A = Œ± ‚â´ P.p) √ó'
      (Œ≤ ‚â´ Q.p = pullback.lift AB Œ± w ‚â´ (PartialProduct.fan P A).snd) :=
  calc
  _ ‚âÉ (Œ≤ : Œì ‚ü∂ D) √ó (Œ±B : Œì ‚ü∂ pullback (PartialProduct.fan P A).fst P.p) √ó'
      Œ≤ ‚â´ Q.p = Œ±B ‚â´ (PartialProduct.fan P A).snd :=
    pullbackHomEquiv
  _ ‚âÉ (Œ≤ : Œì ‚ü∂ D) √ó (Œ±B : (AB : Œì ‚ü∂ P.functor.obj A) √ó (Œ± : Œì ‚ü∂ E) √ó'
        AB ‚â´ P.fstProj A = Œ± ‚â´ P.p) √ó'
      Œ≤ ‚â´ Q.p = pullback.lift Œ±B.1 Œ±B.2.1 Œ±B.2.2 ‚â´ (PartialProduct.fan P A).snd :=
    Equiv.sigmaCongrRight (fun Œ≤ => calc
      _ ‚âÉ (Œ±B : (AB : Œì ‚ü∂ P.functor.obj A) √ó (Œ± : Œì ‚ü∂ E) √ó' (AB ‚â´ P.fstProj A = Œ± ‚â´ P.p)) √ó'
          (Œ≤ ‚â´ Q.p = pullback.lift Œ±B.1 Œ±B.2.1 Œ±B.2.2 ‚â´ (PartialProduct.fan P A).snd) :=
        Equiv.psigmaCongrProp pullbackHomEquiv (fun Œ±B => by
          apply Eq.congr_right
          congr 1
          apply pullback.hom_ext
          ¬∑ simp [pullbackHomEquiv]
          ¬∑ simp [pullbackHomEquiv]))
  _ ‚âÉ _ := {
      -- TODO should be general tactic for this?
      toFun x := ‚ü® x.2.1.1, x.2.1.2.1 , x.1 , x.2.1.2.2, x.2.2 ‚ü©
      invFun x := ‚ü® x.2.2.1 , ‚ü® x.1, x.2.1 , x.2.2.2.1 ‚ü© , x.2.2.2.2 ‚ü©
      left_inv _ := rfl
      right_inv _ := rfl }

end CategoryTheory.UvPoly
