/-
Copyright (c) 2025 Joseph Hua. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Hua, Sina Hazratpour, Emily Riehl
-/

import Mathlib.CategoryTheory.MorphismProperty.OverAdjunction
import Mathlib.CategoryTheory.Functor.TwoSquare
import Mathlib.CategoryTheory.Comma.Over.Pushforward
import Mathlib.CategoryTheory.Limits.Constructions.Over.Basic
import HoTTLean.ForMathlib
import HoTTLean.ForMathlib.CategoryTheory.NatTrans

universe v u v‚ÇÅ u‚ÇÅ

noncomputable section

namespace CategoryTheory

open Category Limits MorphismProperty

variable {C : Type u} [Category.{v} C]

namespace MorphismProperty

instance : (‚ä§ : MorphismProperty C).HasOfPostcompProperty ‚ä§ where
  of_postcomp := by simp

instance (P : MorphismProperty C) {X} : P.HasPullback (ùüô X) where
  hasPullback g hg :=
  have : IsPullback (ùüô _) g g (ùüô X) := IsPullback.of_horiz_isIso (by simp)
  IsPullback.hasPullback this

/-- `Over.pullback` commutes with composition. -/
@[simps! hom_app_left inv_app_left]
noncomputable def Over.pullbackId (P Q : MorphismProperty C) (X)
    [Q.IsMultiplicative] [P.IsStableUnderBaseChange] [Q.IsStableUnderBaseChange]
    [Q.RespectsIso] : Over.pullback P Q (ùüô X) ‚âÖ ùü≠ _ :=
  NatIso.ofComponents (fun X ‚Ü¶ Over.isoMk (asIso (pullback.fst X.hom (ùüô _)))
    (by simp [pullback.condition]))

/-- Fixing a commutative square,
```
   Y - k ‚Üí W
   ‚àß        ‚àß
 f |        | g
   |        |
   X - h ‚Üí Z
```
`pullbackMapTwoSquare` is the Beck-Chevalley natural transformation for `Over.map` between
the `MorphismProperty.Over` categories,
of type `pullback f ‚ãô map h ‚ü∂ map k ‚ãô pullback g`.
```
           map k
 R.Over Y --------> R.Over W
    |                  |
    |                  |
pullback f     ‚Üó    pullback g
    |                  |
    v                  V
 R.Over X  --------> R.Over Z
            map h
```
-/
def pullbackMapTwoSquare {T : Type u} [Category.{v} T] (R : MorphismProperty T)
    [R.IsStableUnderBaseChange] [R.IsStableUnderComposition]
    {X Y Z W : T} (h : X ‚ü∂ Z) (f : X ‚ü∂ Y) (g : Z ‚ü∂ W) (k : Y ‚ü∂ W)
    (rk : R k) (rh : R h)
    [R.HasPullback h] [R.HasPullback f] [R.HasPullback g] [R.HasPullback k]
    (sq : f ‚â´ k = h ‚â´ g) :
    TwoSquare (MorphismProperty.Over.pullback R ‚ä§ f)
      (MorphismProperty.Over.map ‚ä§ rk) (MorphismProperty.Over.map ‚ä§ rh)
      (MorphismProperty.Over.pullback R ‚ä§ g) :=
  (mateEquiv (MorphismProperty.Over.mapPullbackAdj R ‚ä§ k rk trivial)
    (MorphismProperty.Over.mapPullbackAdj R ‚ä§ h rh trivial)).symm <|
    ((MorphismProperty.Over.pullbackComp _ _).inv ‚â´
    eqToHom (by rw! [sq]) ‚â´
    (MorphismProperty.Over.pullbackComp _ _).hom)

/--
The Beck-Chevalley two-square `pushforwardPullbackTwoSquare` is a natural isomorphism
```
           map k
 R.Over Y --------> R.Over W
    |                  |
    |                  |
pullback f     ‚âÖ    pullback g
    |                  |
    v                  V
 R.Over X  --------> R.Over Z
            map h
```
when the commutativity
condition is strengthened to a pullback condition.
```
   Y - k ‚Üí W
   ‚àß        ‚àß
 f |  (pb)  | g
   |        |
   X - h ‚Üí Z
```
TODO: in what generality does this theorem hold?
NOTE: we know it holds when `R` is a clan
([Joyal, Notes on Clans and Tribes, Cor 2.4.11](https://arxiv.org/pdf/1710.10238)).
NOTE: we also know it holds in a category with pullbacks with `R = ‚ä§`.
-/
theorem pullbackMapTwoSquare_isIso {T : Type u} [Category.{v} T] (R : MorphismProperty T)
    [R.IsStableUnderBaseChange] [R.IsStableUnderComposition]
    {X Y Z W : T} (h : X ‚ü∂ Z) (f : X ‚ü∂ Y) (g : Z ‚ü∂ W) (k : Y ‚ü∂ W)
    (rk : R k) (rh : R h)
    [R.HasPullback h] [R.HasPullback f] [R.HasPullback g] [R.HasPullback k]
    (pb : IsPullback f h k g) :
    NatTrans.IsCartesian <| pullbackMapTwoSquare R h f g k rk rh pb.w :=
  sorry

/-- Fixing a commutative square,
```
   Z - g ‚Üí W
   ‚àß        ‚àß
 h |        | k
   |        |
   X - f ‚Üí Y
```
`pushforwardPullbackTwoSquare` is the Beck-Chevalley natural transformation for pushforwards between
the `MorphismProperty.Over` categories,
of type `pushforward g ‚ãô pullback k ‚ü∂ pullback h ‚ãô pushforward f`.
```
      R.Over ‚ä§ Z - pushforward g ‚Üí R.Over ‚ä§ W
           |                           |
pullback h |           ‚Üô              | pullback k
           V                           V
      R.Over ‚ä§ X - pushforward f ‚Üí R.Over ‚ä§ Y
```
It is the mate of the square of pullback functors
`pullback k ‚ãô pullback g ‚ü∂ pullback f ‚ãô pullback h`.
-/
def pushforwardPullbackTwoSquare {T : Type u} [Category.{v} T] {R : MorphismProperty T}
    [R.HasPullbacks] [R.IsStableUnderBaseChange] {Q : MorphismProperty T} [Q.HasPullbacks]
    [R.HasPushforwards Q] [R.IsStableUnderPushforward Q] {X Y Z W : T}
    (h : X ‚ü∂ Z) (f : X ‚ü∂(Q) Y) (g : Z ‚ü∂(Q) W) (k : Y ‚ü∂ W) (sq : h ‚â´ g.1 = f.1 ‚â´ k) :
    TwoSquare (pushforward (P := R) g) (Over.pullback R ‚ä§ h) (Over.pullback R ‚ä§ k)
    (pushforward (P := R) f) :=
  let pullbackTwoSquare : TwoSquare (Over.pullback R ‚ä§ k) (Over.pullback R ‚ä§ g.fst)
      (Over.pullback R ‚ä§ f.fst) (Over.pullback R ‚ä§ h) :=
    ((Over.pullbackComp _ _).inv ‚â´
    eqToHom (by rw! [sq]) ‚â´
    (Over.pullbackComp _ _).hom)
  mateEquiv (pullbackPushforwardAdjunction R Q g)
  (pullbackPushforwardAdjunction R Q f)
  pullbackTwoSquare

/--
The Beck-Chevalley two-square `pushforwardPullbackTwoSquare` is a natural isomorphism
```
      R.Over ‚ä§ Z - pushforward g ‚Üí R.Over ‚ä§ W
           |                           |
pullback h |            ‚âÖ              | pullback k
           V                           V
      R.Over ‚ä§ X - pushforward f ‚Üí R.Over ‚ä§ Y
```
when the commutativity
condition is strengthened to a pullback condition.
```
   Z - g ‚Üí W
   ‚àß        ‚àß
 h |  (pb)  | k
   |        |
   X - f ‚Üí Y
```
TODO: in what generality does this theorem hold?
NOTE: we know it holds when for œÄ-clans with `R = Q = the œÄ-clan`
([Joyal, Notes on Clans and Tribes, Cor 2.4.11](https://arxiv.org/pdf/1710.10238)).
NOTE: we also know it holds in a category with pullbacks with `R = ‚ä§` and `Q = ExponentiableMaps`.
-/
theorem pushforwardPullbackTwoSquare_isIso {T : Type u} [Category.{v} T] (R : MorphismProperty T)
    [R.HasPullbacks] [R.IsStableUnderBaseChange] {Q : MorphismProperty T} [Q.HasPullbacks]
    [R.HasPushforwards Q] [R.IsStableUnderPushforward Q]
    {X Y Z W : T} (h : X ‚ü∂ Z) (f : X ‚ü∂(Q) Y) (g : Z ‚ü∂(Q) W) (k : Y ‚ü∂ W)
    (pb : IsPullback h f.1 g.1 k) : IsIso (pushforwardPullbackTwoSquare (R := R) h f g k pb.w) :=
  sorry

/-
Copyright (c) 2025 Wojciech Nawrocki. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Wojciech Nawrocki
-/

theorem _root_.CategoryTheory.Functor.reflect_commSq
    {C D : Type*} [Category C] [Category D]
    (F : C ‚•§ D) [Functor.Faithful F]
    {X Y Z W : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} {h : Y ‚ü∂ W} {i : Z ‚ü∂ W} :
    CommSq (F.map f) (F.map g) (F.map h) (F.map i) ‚Üí
    CommSq f g h i := by
  intro cs
  constructor
  apply Functor.map_injective F
  simpa [‚Üê Functor.map_comp] using cs.w

theorem _root_.CategoryTheory.Functor.reflect_isPullback
    {C D : Type*} [Category C] [Category D] (F : C ‚•§ D)
    {X Y Z W : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) (h : Y ‚ü∂ W) (i : Z ‚ü∂ W)
    [rl : ReflectsLimit (cospan h i) F] [Functor.Faithful F] :
    IsPullback (F.map f) (F.map g) (F.map h) (F.map i) ‚Üí
    IsPullback f g h i := by
  intro pb
  have sq := F.reflect_commSq pb.toCommSq
  apply IsPullback.mk sq
  apply rl.reflects
  let i := cospanCompIso F h i
  apply IsLimit.equivOfNatIsoOfIso i.symm pb.cone _ _ pb.isLimit
  let j :
      ((Cones.postcompose i.symm.hom).obj pb.cone).pt ‚âÖ
      (F.mapCone <| PullbackCone.mk f g sq.w).pt :=
    Iso.refl _
  apply WalkingCospan.ext j <;> simp +zetaDelta

open NatTrans MorphismProperty.Over in
/-- The counit of the adjunction `mapPullbackAdj` is a pullback square,
since it is the pullback computed by `P.Over.pullback`. -/
lemma isCartesian_mapPullbackAdj_counit {P : MorphismProperty C} {X Y : C} {f : X ‚ü∂ Y}
    [P.IsStableUnderComposition] [P.IsStableUnderBaseChange]
    [P.HasPullback f] (hPf : P f) : IsCartesian (mapPullbackAdj P ‚ä§ f hPf trivial).counit := by
  intro A B U
  apply (MorphismProperty.Over.forget P ‚ä§ Y).reflect_isPullback
  apply (CategoryTheory.Over.forget Y).reflect_isPullback
  apply IsPullback.flip
  simp only [Functor.comp_obj, Comma.forget_obj, Over.forget_obj, map_obj_left, pullback_obj_left,
    Functor.id_obj, mapPullbackAdj, Adjunction.mkOfHomEquiv, morphismProperty_fst,
    Functor.const_obj_obj, map_obj_hom, Equiv.coe_fn_mk, Comma.id_hom, CategoryTheory.Comma.id_left,
    id_comp, Adjunction.mk'_counit, Comma.forget_map, homMk_hom, Over.forget_map, Over.homMk_left,
    Functor.comp_map, map_map_left, pullback_map_left, Functor.id_map]
  apply IsPullback.of_bot (v‚ÇÇ‚ÇÅ := (pullback.snd B.hom f)) (h‚ÇÉ‚ÇÅ := f) (v‚ÇÇ‚ÇÇ := B.hom) _ _
    (IsPullback.of_hasPullback B.hom f)
  ¬∑ convert IsPullback.of_hasPullback A.hom f <;> simp
  ¬∑ simp

namespace PolynomialPartialAdjunction

variable {T : Type u} [Category.{v} T] {R : MorphismProperty T}
  [R.HasPullbacks] [R.IsStableUnderBaseChange]
  {Q : MorphismProperty T} [Q.HasPullbacks] [R.HasPushforwards Q]
  [R.IsStableUnderPushforward Q]
  {E I B : T} (i : E ‚ü∂ I) (p : E ‚ü∂(Q) B)

/-- The partial right adjoint representing a multivariate polynomial. -/
abbrev partialRightAdjoint := Over.pullback R ‚ä§ i ‚ãô pushforward R p

/-- The left adjoint in the partial adjunction. -/
abbrev leftAdjoint := CategoryTheory.Over.pullback p.1 ‚ãô CategoryTheory.Over.map i

/-- `pullback R ‚ä§ i ‚ãô pushforward R p` is a partial right adjoint to
`CategoryTheory.Over.pullback p.1 ‚ãô CategoryTheory.Over.map i`
  ```
         pullback i       pushforward p
   R.Over I ------> R.Over E -----> R.Over B
      |               |                |
      |       ‚ä•       |        ‚ä•       |
      |               |                |
      V               V                V
     C/I <--------- C/E <------------ C/B
            map i         pullback p
  ```

On paper this is written `C/B (X, p‚Åé (i* Y)) ‚âÉ C/I (i! (p* X), Y)`.
-/
def homEquiv {X : Over B} {Y : R.Over ‚ä§ I} :
    (X ‚ü∂ ((partialRightAdjoint i p).obj Y).toComma) ‚âÉ
    ((leftAdjoint i p).obj X ‚ü∂ Y.toComma) :=
  calc (X ‚ü∂ ((R.pushforward p).obj ((Over.pullback R ‚ä§ i).obj Y)).toComma)
  _ ‚âÉ ((CategoryTheory.Over.pullback p.1).obj X ‚ü∂ ((Over.pullback R ‚ä§ i).obj Y).toComma) :=
    pushforward.homEquiv ..
  _ ‚âÉ ((CategoryTheory.Over.map i).obj
      ((CategoryTheory.Over.pullback p.fst).obj X) ‚ü∂ Y.toComma) :=
    pullback.homEquiv ..

lemma homEquiv_comp {X X' : Over B} {Y : R.Over ‚ä§ I}
    (f : X' ‚ü∂ ((partialRightAdjoint i p).obj Y).toComma) (g : X ‚ü∂ X') :
    homEquiv i p (g ‚â´ f) =
    (leftAdjoint i p).map g ‚â´ homEquiv i p f := by
  unfold homEquiv
  simp only [Functor.comp_obj, Equiv.trans_def, Equiv.trans_apply]
  erw [pushforward.homEquiv_comp, pullback.homEquiv_comp]
  rfl

lemma homEquiv_map_comp {X : Over B} {Y Y' : R.Over ‚ä§ I}
    (f : X ‚ü∂ ((partialRightAdjoint i p).obj Y).toComma) (g : Y ‚ü∂ Y') :
    homEquiv i p (f ‚â´ Comma.Hom.hom ((partialRightAdjoint i p).map g)) =
    homEquiv i p f ‚â´ Comma.Hom.hom g := by
  unfold homEquiv
  simp only [Functor.comp_obj, Equiv.trans_def, Equiv.trans_apply]
  erw [pushforward.homEquiv_map_comp, pullback.homEquiv_map_comp]
  rfl

lemma homEquiv_symm_comp {X : Over B} {Y Y' : R.Over ‚ä§ I}
    (f : (leftAdjoint i p).obj X ‚ü∂ Y.toComma) (g : Y ‚ü∂ Y') :
    (homEquiv i p).symm f ‚â´ Comma.Hom.hom ((partialRightAdjoint i p).map g) =
    (homEquiv i p).symm (f ‚â´ Comma.Hom.hom g) := by
  unfold homEquiv
  simp
  erw [pushforward.homEquiv_symm_comp, pullback.homEquiv_symm_comp]
  rfl

lemma homEquiv_comp_symm {X X' : Over B} {Y : R.Over ‚ä§ I}
    (f : (leftAdjoint i p).obj X' ‚ü∂ Y.toComma) (g : X ‚ü∂ X') :
    g ‚â´ (homEquiv i p).symm f =
    (homEquiv i p).symm ((leftAdjoint i p).map g ‚â´ f) := by
  unfold homEquiv
  simp
  erw [pushforward.homEquiv_comp_symm, pullback.homEquiv_comp_symm]
  rfl

/-- The counit of the partial adjunction is given by evaluating the equivalence of
hom-sets at the identity.
On paper we write this as `counit : i! p* p‚àó i* => Over.forget : R.Over ‚ä§ I ‚•§ Over I`
-/
def counit :
    partialRightAdjoint i p ‚ãô Over.forget R ‚ä§ B ‚ãô leftAdjoint i p ‚ü∂ Over.forget R ‚ä§ I where
  app _ := homEquiv i p (ùüô _)
  naturality X Y f := by
    apply (homEquiv i p).symm.injective
    conv => left; erw [‚Üê homEquiv_comp_symm]
    conv => right; erw [‚Üê homEquiv_symm_comp]
    simp

/-- A commutative diagram
```
      I
    ‚Üó  ‚Üñ
 i /      \ i'
  /   œÅ    \
 E -------> E'
  \        /
 p \      / p'
    ‚Üò  ‚Üô
      B
```
induces a natural transformation `partialRightAdjoint i p ‚ü∂ partialRightAdjoint i' p'`
obtained by pasting the following 2-cells
```
        pullback i'        pushforward p'
R.Over ‚ä§ I ---->  R.Over ‚ä§ E' ----> R.Over ‚ä§ B
    ‚Äñ                 |                  ‚Äñ
    ‚Äñ                 |                  ‚Äñ
    ‚Äñ       ‚Üô        |œÅ*      ‚Üô        ‚Äñ
    ‚Äñ                 |                  ‚Äñ
    ‚Äñ                 V                  ‚Äñ
R.Over ‚ä§ I ---->  R.Over ‚ä§ E  ----> R.Over ‚ä§ B
        pullback i         pushforward p
```
-/
def partialRightAdjointMap {E' : T} (i' : E' ‚ü∂ I) (p' : E' ‚ü∂(Q) B) (œÅ)
    (hi : i = œÅ ‚â´ i') (hp : p.1 = œÅ ‚â´ p'.1) :
    partialRightAdjoint (R := R) i' p' ‚ü∂ partialRightAdjoint i p :=
  let cellLeftIso : Over.pullback R ‚ä§ i' ‚ãô Over.pullback R ‚ä§ œÅ ‚âÖ Over.pullback R ‚ä§ i :=
    (Over.pullbackComp œÅ i').symm ‚â™‚â´ eqToIso (by rw [hi])
  let cellLeft : TwoSquare (Over.pullback R ‚ä§ i') (ùü≠ _) (Over.pullback R ‚ä§ œÅ) (Over.pullback R ‚ä§ i) :=
    ((Over.pullbackComp œÅ i').symm ‚â™‚â´ eqToIso (by simp [hi, Functor.id_comp])).hom
  let cellRight := pushforwardPullbackTwoSquare (R := R) (Q := Q) œÅ p p' (ùüô _) (by simp [‚Üê hp])
  Functor.whiskerLeft (partialRightAdjoint i' p') (Over.pullbackId R ‚ä§ B).inv ‚â´
  cellLeft.hComp cellRight

end PolynomialPartialAdjunction

variable (P : MorphismProperty C)

namespace Over

@[simps]
def equivalenceOfHasObjects' (R : MorphismProperty C) [R.HasObjects]
    {X : C} (hX : IsTerminal X) : R.Over ‚ä§ X ‚âå Over X where
  functor := MorphismProperty.Over.forget _ _ _
  inverse := Comma.lift (ùü≠ _) (by intro; apply HasObjects.obj_mem _ hX) (by simp) (by simp)
  unitIso := eqToIso rfl
  counitIso := eqToIso rfl
  functor_unitIso_comp := by simp

@[simp]
def equivalenceOfHasObjects (R : MorphismProperty C) [R.HasObjects]
    {X : C} (hX : IsTerminal X) : R.Over ‚ä§ X ‚âå C :=
  (equivalenceOfHasObjects' R hX).trans (Over.equivalenceOfIsTerminal hX)

variable {P : MorphismProperty C} {E B : C}

@[simps]
def ofMorphismProperty (p : E ‚ü∂(P) B) : P.Over ‚ä§ B where
  left := E
  right := ‚ü®‚ü®‚ü©‚ü©
  hom := p.1
  prop := p.2

@[simps]
def homMkTop {p q : P.Over ‚ä§ B} (left : p.left ‚ü∂ q.left) (hleft : left ‚â´ q.hom = p.hom) :
    p ‚ü∂ q where
  left := left
  right := eqToHom (by simp)
  w := by simp [hleft]
  prop_hom_left := trivial
  prop_hom_right := trivial

/--
Convert an object `p` in `R.Over ‚ä§ B` to a morphism in `R.Over ‚ä§ O` by composing with `o`.
     p
 E -----> B
  \      /
   \    /o
    \  /
     VV
     O
-/
@[simp]
def homOfMorphismProperty [P.IsStableUnderComposition] {O} (p : P.Over ‚ä§ B) (o : B ‚ü∂(P) O) :
    (map ‚ä§ o.2).obj p ‚ü∂ Over.ofMorphismProperty o :=
  Over.homMk p.hom (by simp)

end Over

end MorphismProperty

open MorphismProperty.Over

/-- `P : MvPoly R H I O` is a the signature for a multivariate polynomial functor,
consisting of the following maps
```
         p
      E ---> B
  i ‚Üô         ‚Üò o
  I               O
```
We can lazily read this as `‚àë b : B, X ^ (E b)`,
for some `X` in the (`P`-restricted) slice over `I`.

In full detail:
Viewing such an `X` as a series of variables `X_k` indexed by `k ‚àà I`,
and `B` as a family of types `B_k` indexed by `j ‚àà O`
this can be further viewed as `O`-many `I`-ary polynomials `‚àë b : B_j, X_(i b) ^ (E b)`

To explain the need for two morphism properties,
consider the following two use-cases:
1. `R = ‚ä§` is all maps and the category has all pullbacks.
  `H` is the class of exponentiable maps - it follows from all maps having pullbacks that `H`
  also has pullbacks.
2. `R = H` is a œÄ-clan, [see Joyal, def 2.4.1](https://arxiv.org/pdf/1710.10238).

This will typically be used with the following instances

- For pullback of `R`-maps along `i`, `p` and `o` we need
  `[R.IsStableUnderBaseChange] [R.HasPullbacks]`
- For the left adjoint to pullback for `o` we need `[R.IsStableUnderComposition]`
- For pushforward of `R`-maps along `p` we need
  `[R.IsStableUnderPushforward H] [R.HasPushforwards H]`
- For pushforward of `R`-maps along `p` we also assume `[H.HasPullbacks]`.
  This is useful - it makes the `R`-restricted pushforward of `R`-maps along `p`
  a partial left adjoint to *global* pullback along `p`,
  ```
        pushforward p
   R.Over E -----> R.Over B
      |              |
      |       ‚ä•      |
      |              |
      V              V
     C/E <--------- C/B
         pullback p
  ```
  which is strictly stronger than just having a left adjoint to `R`-restricted pullback
  `(pullback : R.Over B ‚•§ R.Over E) ‚ä£ (pushforward : R.Over E ‚•§ R.Over B)`.
-/
structure MvPoly (R : MorphismProperty C) (H : MorphismProperty C) (I O E B : C) where
  (i : E ‚ü∂(R) I)
  (p : E ‚ü∂(H) B)
  (o : B ‚ü∂(R) O)

namespace MvPoly

variable {R : MorphismProperty C} {H : MorphismProperty C}

instance {B O : C} (i : B ‚ü∂(R) O) [R.HasPullbacks] [R.IsStableUnderBaseChange]
    [R.IsStableUnderComposition] : (pullback R ‚ä§ i.1).IsRightAdjoint :=
  (mapPullbackAdj R ‚ä§ i.1 i.2 ‚ü®‚ü©).isRightAdjoint

instance [R.IsStableUnderComposition] {X Y} (f : X ‚ü∂ Y) (hf : R f) :
    Limits.PreservesLimitsOfShape WalkingCospan (MorphismProperty.Over.map ‚ä§ hf) :=
  sorry

variable {I O E B : C} (P : MvPoly R H I O E B) [R.HasPullbacks] [R.IsStableUnderBaseChange]
    [H.HasPullbacks] [R.HasPushforwards H]
    [R.IsStableUnderPushforward H]

open PolynomialPartialAdjunction

/-- (Ignoring the indexing from `i` and `o`)
This is the first projection morphism from `P @ X = ‚àë b : B, X ^ (E b)` to `B`,
as an object in the `P`-restricted slice over `B`. -/
abbrev fstProj (P : MvPoly R H I O E B) (X : R.Over ‚ä§ I) : R.Over ‚ä§ B :=
  (partialRightAdjoint P.i.1 P.p).obj X

/-- The counit of the adjunction `pullback p ‚ãô map i ‚ä£ pullback i ‚ãô pushforward p` evaluated at `X`.
Ignoring the indexing from `i` and `o`,
this can be viewed as the second projection morphism from `P @ X = ‚àë b : B, X ^ (E b)`
to `X^ (E b)`.

```
     X ----------> I
     ‚àß             ‚àß
     |             |
 sndProj           | i
     |             |
     ‚Ä¢ ----------> E
     |             |
     |    (pb)     |
     |             |p
     V    fstProj  V
   P @ X --------> B
       ‚üç          |
          ‚üç       |o
             ‚üç    |
                ‚Üò V
                   O
```
-/
def sndProj (P : MvPoly R H I O E B) (X : R.Over ‚ä§ I) :
    (leftAdjoint P.i.1 P.p).obj (fstProj P X).toComma ‚ü∂ X.toComma :=
  (counit P.i.1 P.p).app X

section

variable (P : MvPoly R H I O E B) {X Y : R.Over ‚ä§ I} (f : X ‚ü∂ Y)

@[reassoc (attr := simp)]
lemma map_fstProj :
    ((partialRightAdjoint P.i.1 P.p).map f).left ‚â´ (fstProj P Y).hom = (fstProj P X).hom := by
  simp

lemma sndProj_comp_hom : (sndProj P X).left ‚â´ X.hom = pullback.snd _ _ ‚â´ P.i.1 := by
  simp [sndProj]

lemma sndProj_comp : (sndProj P X).left ‚â´ f.left =
    pullback.map _ _ _ _
      ((partialRightAdjoint P.i.1 P.p).map f).left (ùüô _) (ùüô _) (by simp) (by simp) ‚â´
      (sndProj P Y).left := by
  have := congr_arg CommaMorphism.left <| (counit P.i.1 P.p).naturality f
  simpa [pullback.map] using this.symm

end

variable [R.IsStableUnderComposition]
/-- A multivariate polynomial signature
```
         p
      E ---> B
  i ‚Üô         ‚Üò o
  I               O
```
gives rise to a functor
```
                         pushforward p
                R.Over ‚ä§ E ---------> R.Over ‚ä§ B
     pullback i ‚Üó                              ‚üç map o
             ‚üã                                    ‚üç
          ‚üã                                          ‚Üò
  R.Over ‚ä§ I                                      R.Over ‚ä§ O
```
-/
def functor : R.Over ‚ä§ I ‚•§ R.Over ‚ä§ O :=
  pullback R ‚ä§ P.i.1 ‚ãô MorphismProperty.pushforward R P.p ‚ãô map ‚ä§ P.o.2

/-- The action of a univariate polynomial on objects. -/
def apply (P : MvPoly R H I O E B) : R.Over ‚ä§ I ‚Üí R.Over ‚ä§ O := (functor P).obj

@[inherit_doc]
infix:90 " @ " => apply

namespace Equiv

variable {P : MvPoly R H I O E B} {Œì : Over O} {X : R.Over ‚ä§ I}

def fst (pair : Œì ‚ü∂ (P @ X).toComma) : Over B := Over.mk (pair.left ‚â´ (fstProj P X).hom)

abbrev sndDom (pair : Œì ‚ü∂ (P @ X).toComma) : Over I := (leftAdjoint P.i.1 P.p).obj (fst pair)

def snd (pair : Œì ‚ü∂ (P @ X).toComma) : sndDom pair ‚ü∂ X.toComma :=
  homEquiv P.i.1 P.p (Over.homMk (pair.left))

lemma snd_eq (pair : Œì ‚ü∂ (P @ X).toComma) : snd pair =
    (leftAdjoint P.i.1 P.p).map (Over.homMk (pair.left)) ‚â´ sndProj P X := by
  erw [Equiv.apply_eq_iff_eq_symm_apply, ‚Üê homEquiv_comp_symm]
  simp [sndProj, counit]

def mk (f : Over B) (hf : Œì = (Over.map P.o.1).obj f)
    (s : (leftAdjoint P.i.1 P.p).obj f ‚ü∂ X.toComma) :
    Œì ‚ü∂ (P @ X).toComma :=
  eqToHom hf ‚â´ (Over.map P.o.fst).map ((homEquiv P.i.1 P.p).symm s)

@[simp]
lemma fst_mk (f : Over B) (hf : Œì = (Over.map P.o.1).obj f)
    (s : (leftAdjoint P.i.1 P.p).obj f ‚ü∂ X.toComma) : fst (mk f hf s) = f := by
  subst hf; simp [fst, mk]; rfl

lemma snd_mk (f : Over B) (hf : Œì = (Over.map P.o.1).obj f)
    (s : (leftAdjoint P.i.1 P.p).obj f ‚ü∂ X.toComma) : snd (mk f hf s) =
    eqToHom (by simp) ‚â´ s := calc snd (mk f hf s)
  _ = (leftAdjoint P.i.1 P.p).map (eqToHom (fst_mk f hf s)) ‚â´ s := by
    erw [Equiv.apply_eq_iff_eq_symm_apply, ‚Üê homEquiv_comp_symm]
    ext
    simp [mk]
  _ = eqToHom _ ‚â´ s := by
    simp only [eqToHom_map]

@[simp]
lemma map_fst (pair : Œì ‚ü∂ (P @ X).toComma) : (Over.map P.o.fst).obj (fst pair) = Œì := by
  have := pair.w
  simp only [Functor.id_obj, Functor.const_obj_obj, Functor.id_map,
    CostructuredArrow.right_eq_id, Functor.const_obj_map, comp_id] at this
  simp [Over.map, Comma.mapRight, fst]
  congr

@[simp]
lemma eta (pair : Œì ‚ü∂ (P @ X).toComma) : mk (fst pair) (by simp) (snd pair) = pair := by
  ext
  simp [mk, snd]

end Equiv

instance (X Y) (Œ¥ : X ‚ü∂ Y) (rŒ¥ : R Œ¥) : (MorphismProperty.Over.pullback R ‚ä§ Œ¥).IsRightAdjoint :=
    Adjunction.isRightAdjoint (MorphismProperty.Over.mapPullbackAdj R ‚ä§ Œ¥ rŒ¥ trivial)

-- (MorphismProperty.Over.pullback R ‚ä§ Œ¥ ‚ãô MorphismProperty.Over.map ‚ä§ ‚ãØ)
instance (P : MvPoly R H I O E B) : PreservesLimitsOfShape WalkingCospan
    (MorphismProperty.Over.pullback R ‚ä§ P.i.fst ‚ãô R.pushforward P.p ‚ãô
    MorphismProperty.Over.map ‚ä§ P.o.2) :=
  inferInstance

instance (P : MvPoly R H I O E B) :
    Limits.PreservesLimitsOfShape WalkingCospan (MvPoly.functor P) := by
  dsimp [functor]
  infer_instance

/-- A commutative triangle
```
      I
    ‚Üó  ‚Üñ
P.i/      \Q.i
  /    œÅ   \
 E -------> F
  \        /
P.p\      / Q.p
    ‚Üò  ‚Üô
      B
```
induces a natural transformation `Q.functor ‚ü∂ P.functor` when `Q.o = P.o`,
obtained by pasting the following 2-cells
```
        pullback Q.i     pushforward Q.p.1     map Q.o.1
R.Over ‚ä§ I ---->  R.Over ‚ä§ F ----> R.Over ‚ä§ B -----> R.Over ‚ä§ O
    ‚Äñ                 |                  ‚Äñ                ‚Äñ
    ‚Äñ                 |                  ‚Äñ                ‚Äñ
    ‚Äñ       ‚Üô        |œÅ*      ‚Üô        ‚Äñ       =        ‚Äñ
    ‚Äñ                 |                  ‚Äñ                ‚Äñ
    ‚Äñ                 V                  ‚Äñ                ‚Äñ
R.Over ‚ä§ I ---->  R.Over ‚ä§ E ----> R.Over ‚ä§ B -----> R.Over ‚ä§ O
        pullback P.i     pushforward P.p.1     map P.o.1
```
-/
def verticalNatTrans {F : C} (P : MvPoly R H I O E B) (Q : MvPoly R H I O F B) (œÅ : E ‚ü∂ F)
    (hi : P.i.1 = œÅ ‚â´ Q.i.1) (hp : P.p.1 = œÅ ‚â´ Q.p.1) (ho : P.o.1 = Q.o.1) :
    Q.functor ‚ü∂ P.functor :=
  (Functor.associator _ _ _).inv ‚â´
  ((PolynomialPartialAdjunction.partialRightAdjointMap P.i.1 P.p Q.i.1 Q.p œÅ hi hp) ‚ó´
  (eqToHom (by rw! [ho]))) ‚â´
  (Functor.associator _ _ _).hom

section

variable {F} (Q : MvPoly R H I O F B) (œÅ : E ‚ü∂ F) (hi : P.i.1 = œÅ ‚â´ Q.i.1)
    (hp : P.p.1 = œÅ ‚â´ Q.p.1) (ho : P.o.1 = Q.o.1)

lemma fst_verticalNatTrans_app {Œì} {X} (pair : Œì ‚ü∂ (Q @ X).toComma) :
    Equiv.fst (pair ‚â´ ((verticalNatTrans P Q œÅ hi hp ho).app X).hom) = Equiv.fst pair := by
  -- simp [verticalNatTrans, partialRightAdjointMap]
  -- erw [Category.id_comp]
  -- dsimp [Equiv.fst]
  -- congr 1
  sorry

-- lemma snd'_verticalNatTrans_app {Œì} {X} (pair : Œì ‚ü∂ (Q @ X).toComma) :
--     Equiv.snd (pair ‚â´ ((verticalNatTrans P Q œÅ hi hp ho).app X).hom) =
--     --(H.lift f' (g' ‚â´ œÅ) (by simp [H'.w, h])) ‚â´
--     sorry ‚â´ Equiv.snd pair := by
--   sorry

-- lemma mk'_comp_verticalNatTrans_app {Œì : Over O} {X : R.Over ‚ä§ I} (f : Over B)
--     (hf : Œì = (Over.map Q.o.1).obj f) (s : (leftAdjoint Q.i.1 Q.p).obj f ‚ü∂ X.toComma) :
--     Equiv.mk f hf s ‚â´ ((verticalNatTrans P Q œÅ hi hp ho).app X).hom =
--     Equiv.mk f (sorry) sorry ‚â´ sorry
--      :=
--   sorry

end

open TwoSquare

/-- A cartesian map
```
               P.p
          E  -------->  B
  P.i ‚Üô  |             |  ‚Üò P.o
     I   œÜ|    (pb)     | Œ¥  O
  P'.i ‚Üñ v             v  ‚Üó P'.o
          E' -------->  B'
               P'.p
```
induces a natural transformation between their associated functors obtained by pasting the following
2-cells
```
        pullback P'.i      pushforward P'.p       map P'.o
R.Over I ------ >  R.Over E' --------> R.Over B' --------> R.Over O
    ‚Äñ                |                     |                  ‚Äñ
    ‚Äñ                |                     |                  ‚Äñ
    ‚Äñ       ‚Üó    pullback œÜ   ‚Üó     pullback Œ¥     ‚Üó       ‚Äñ
    ‚Äñ                |                     |                  ‚Äñ
    ‚Äñ                v                     v                  ‚Äñ
R.Over I ------ >  R.Over E  --------> R.Over B  --------> R.Over O
        pullback P.i       pushforward P.p        map P.o
```
-/
def cartesianNatTrans {E' B' : C} (P : MvPoly R H I O E B) (P' : MvPoly R H I O E' B')
    (Œ¥ : B ‚ü∂ B') (œÜ : E ‚ü∂ E') (hœÜ : P.i.1 = œÜ ‚â´ P'.i.1) (pb : IsPullback œÜ P.p.1 P'.p.1 Œ¥)
    (hŒ¥ : Œ¥ ‚â´ P'.o.1 = P.o.1) :
    P.functor ‚ü∂ P'.functor :=
  let cellLeft : TwoSquare (ùü≠ (R.Over ‚ä§ I)) (MorphismProperty.Over.pullback R ‚ä§ P'.i.1)
      (MorphismProperty.Over.pullback R ‚ä§ P.i.1) (MorphismProperty.Over.pullback R ‚ä§ œÜ) :=
    (eqToIso (by simp [hœÜ, Functor.id_comp]) ‚â™‚â´ (MorphismProperty.Over.pullbackComp œÜ P'.i.1)).hom
  have : IsIso (pushforwardPullbackTwoSquare (R := R) œÜ P.p P'.p Œ¥ pb.w) :=
    pushforwardPullbackTwoSquare_isIso R œÜ P.p P'.p Œ¥ pb
  let cellMid : TwoSquare (MorphismProperty.Over.pullback R ‚ä§ œÜ)
    (R.pushforward P'.p) (R.pushforward P.p) (MorphismProperty.Over.pullback R ‚ä§ Œ¥) :=
    CategoryTheory.inv (pushforwardPullbackTwoSquare œÜ P.p P'.p Œ¥ pb.w)
  let cellRight : TwoSquare (MorphismProperty.Over.pullback R ‚ä§ Œ¥)
      (MorphismProperty.Over.map ‚ä§ P'.o.2) (MorphismProperty.Over.map ‚ä§ P.o.2) (ùü≠ _) :=
    (pullbackMapTwoSquare R P.o.1 Œ¥ (ùüô _) P'.o.1 P'.o.2 P.o.2 (by simp [hŒ¥])) ‚â´
    Functor.whiskerLeft _ (MorphismProperty.Over.pullbackId R ‚ä§ O).hom
  cellLeft ‚â´·µ• cellMid ‚â´·µ• cellRight

open NatTrans in
theorem isCartesian_cartesianNatTrans {E' B' : C} (P : MvPoly R H I O E B) (P' : MvPoly R H I O E' B')
    (Œ¥ : B ‚ü∂ B') (œÜ : E ‚ü∂ E') (hœÜ : P.i.1 = œÜ ‚â´ P'.i.1) (pb : IsPullback œÜ P.p.1 P'.p.1 Œ¥)
    (hŒ¥ : Œ¥ ‚â´ P'.o.1 = P.o.1) :
    (cartesianNatTrans P P' Œ¥ œÜ hœÜ pb hŒ¥).IsCartesian := by
  dsimp [cartesianNatTrans]
  -- NOTE: this lemma could be extracted, but `repeat' apply IsCartesian.comp` will unfold past it.
  -- have : NatTrans.IsCartesian
  --     (pullbackMapTwoSquare R P.o.1 Œ¥ (ùüô _) P'.o.1 P'.o.2 P.o.2 (by simp [hŒ¥])) := by
  --   -- unfold pullbackMapTwoSquare
  --   -- simp only [mateEquiv_symm_apply]
  --   repeat' apply IsCartesian.comp
  --   -- have (i j : R.Over ‚ä§ B') (f : j ‚ü∂ i) :
  --   -- PreservesLimit
  --   --   (cospan ((mapPullbackAdj R ‚ä§ P'.o.fst P'.o.snd trivial).unit.app i)
  --   --     ((MorphismProperty.Over.map ‚ä§ P'.o.2 ‚ãô MorphismProperty.Over.pullback R ‚ä§ P'.o.fst).map f))
  --   --   (MorphismProperty.Over.pullback R ‚ä§ Œ¥ ‚ãô MorphismProperty.Over.map ‚ä§ P.o.2) := sorry
  --   any_goals apply isCartesian_of_isIso
  --   ¬∑ sorry --refine IsCartesian.whiskerRight _ _
  --   ¬∑ apply IsCartesian.whiskerLeft
  --     apply isCartesian_mapPullbackAdj_counit
  repeat' apply IsCartesian.comp
  any_goals apply isCartesian_of_isIso
  apply IsCartesian.whiskerLeft
  repeat' apply IsCartesian.comp
  any_goals apply isCartesian_of_isIso
  apply IsCartesian.whiskerLeft
  repeat' apply IsCartesian.comp
  any_goals apply isCartesian_of_isIso
  ¬∑ sorry -- apply IsCartesian.whiskerRight
  ¬∑ apply IsCartesian.whiskerLeft
    apply isCartesian_mapPullbackAdj_counit

end MvPoly

/-- `P : UvPoly R E B` is the type of signatures for polynomial functors
         p
      E ---> B

We read this as `‚àë b : B, X ^ (E b)`,
for some `R`-object `X` (meaning the unique map to the terminal object is in `R`).

This notion of polynomial makes sense when `R` is a œÄ-clan,
[see Joyal, def 2.4.1](https://arxiv.org/pdf/1710.10238).
Therefore it will typically be used with the following instances

- For pullback of `R`-maps along `p` we need
  `[R.IsStableUnderBaseChange] [R.HasPullbacks]`
- For the left adjoint to pullback along `B`, we assume `[R.IsStableUnderComposition]`
  and `[R.HasObjects]`, meaning the unique map `B ‚ü∂ ‚ä§_ C` is in `R`.
  For this, we will also assume `[ChosenTerminal C]`.
- For pushforward of `R`-maps along `p` we need
  `[R.IsStableUnderPushforward R] [R.HasPushforwards R]`
- For pushforward of `R`-maps along `p` we also assume `[R.HasPullbacks]`.
  This is useful - it makes the `R`-restricted pushforward of `R`-maps along `p`
  a partial left adjoint to *global* pullback along `p`,
  ```
        pushforward p
   R.Over E -----> R.Over B
      |              |
      |       ‚ä•      |
      |              |
      V              V
     C/E <--------- C/B
         pullback p
  ```
  which is strictly stronger than just having a left adjoint to `R`-restricted pullback
  `(pullback : R.Over B ‚•§ R.Over E) ‚ä£ (pushforward : R.Over E ‚•§ R.Over B)`.
-/
structure UvPoly (R : MorphismProperty C) (E B : C) where
  (p : E ‚ü∂ B)
  (morphismProperty : R p)

namespace UvPoly

section

variable {R : MorphismProperty C} {E B : C}

variable [ChosenTerminal C]

open ChosenTerminal

variable [R.IsStableUnderComposition] [R.HasPullbacks] [R.IsStableUnderBaseChange] [R.HasObjects]
  [R.IsStableUnderPushforward R] [R.HasPushforwards R]

abbrev morphismProperty' (P : UvPoly R E B) : E ‚ü∂(R) B := ‚ü® P.p, P.morphismProperty ‚ü©

instance (P : UvPoly R E B) {Œì : C} (A : Œì ‚ü∂ B) : HasPullback A P.p := by
  convert_to HasPullback A (morphismProperty' P).1
  apply MorphismProperty.instHasPullbackFstHomOfHasPullbacks

instance (P : UvPoly R E B) {Œì : C} (A : Œì ‚ü∂ B) : HasPullback P.p A :=
  hasPullback_symmetry _ _

def object (X : C) : X ‚ü∂(R) (ùü≠_ C) :=
  ‚ü® isTerminal.from X, HasObjects.obj_mem _ ChosenTerminal.isTerminal‚ü©

@[simp]
abbrev toOverTerminal : C ‚•§ R.Over ‚ä§ (ùü≠_ C) :=
  (equivalenceOfHasObjects R isTerminal).inverse

@[simp]
abbrev fromOverTerminal : R.Over ‚ä§ (ùü≠_ C) ‚•§ C :=
  (equivalenceOfHasObjects R isTerminal).functor

@[simps]
def mvPoly (P : UvPoly R E B) : MvPoly R R (ùü≠_ C) (ùü≠_ C) E B where
  i := object E
  p := morphismProperty' P
  o := object B

def functor (P : UvPoly R E B) : C ‚•§ C :=
  toOverTerminal ‚ãô
  MvPoly.functor P.mvPoly ‚ãô
  fromOverTerminal

/-- The action of a univariate polynomial on objects. -/
def apply [ChosenTerminal C] (P : UvPoly R E B) : C ‚Üí C := P.functor.obj

@[inherit_doc]
infix:90 " @ " => apply

instance [ChosenTerminal C] (P : UvPoly R E B) :
    Limits.PreservesLimitsOfShape WalkingCospan P.functor := by
  unfold functor
  infer_instance

variable (B)

/-- The identity polynomial functor in single variable. -/
@[simps!]
def id (R : MorphismProperty C) [R.ContainsIdentities] (B) : UvPoly R B B := ‚ü®ùüô B, R.id_mem _ ‚ü©

@[simps!]
def vcomp [R.IsStableUnderComposition] {A B C} (P : UvPoly R A B) (Q : UvPoly R B C) :
    UvPoly R A C :=
  ‚ü® P.p ‚â´ Q.p, R.comp_mem _ _ P.morphismProperty Q.morphismProperty ‚ü©

variable {B}

/-- The fstProjection morphism from `‚àë b : B, X ^ (E b)` to `B` again. -/
def fstProj (P : UvPoly R E B) (X : C) : P @ X ‚ü∂ B :=
  (P.mvPoly.fstProj (toOverTerminal.obj X)).hom

@[reassoc (attr := simp)]
lemma map_fstProj (P : UvPoly R E B) {X Y : C} (f : X ‚ü∂ Y) :
    P.functor.map f ‚â´ fstProj P Y = fstProj P X :=
  P.mvPoly.map_fstProj (toOverTerminal.map f)

/-- The second projection morphism from `P @ X = ‚àë b : B, X ^ (E b)` to `X^ (E b)`. -/
def sndProj (P : UvPoly R E B) (X : C) :
    Limits.pullback (fstProj P X) P.p ‚ü∂ X :=
  (P.mvPoly.sndProj (toOverTerminal.obj X)).left

lemma sndProj_comp (P : UvPoly R E B) {X Y : C} (f : X ‚ü∂ Y) :
    sndProj P X ‚â´ f =
    pullback.map _ _ _ _ (P.functor.map f) (ùüô _) (ùüô _) (by simp) (by simp) ‚â´ sndProj P Y :=
  P.mvPoly.sndProj_comp (toOverTerminal.map f)

open TwoSquare

/-- A commutative triangle
```
      I
    ‚Üó  ‚Üñ
P.i/      \Q.i
  /    œÅ   \
 E -------> F
  \        /
P.p\      / Q.p
    ‚Üò  ‚Üô
      B
```
induces a natural transformation `Q.functor ‚ü∂ P.functor ` obtained by pasting the following 2-cells
```
                  Q.mvPoly.functor
C --- ‚âÖ ---> R.Over ‚ä§ 1 ----> R.Over ‚ä§ 1 --- ‚âÖ ---> C
‚Äñ                ‚Äñ                 ‚Äñ                ‚Äñ
‚Äñ                ‚Äñ                 ‚Äñ                ‚Äñ
‚Äñ                ‚Äñ        ‚Üì       ‚Äñ                ‚Äñ
‚Äñ                ‚Äñ                 ‚Äñ                ‚Äñ
‚Äñ                ‚Äñ                 ‚Äñ                ‚Äñ
C --- ‚âÖ ---> R.Over ‚ä§ 1 ----> R.Over ‚ä§ 1 --- ‚âÖ ---> C
                 P.mvPoly.functor
```
-/
def verticalNatTrans {F : C} (P : UvPoly R E B) (Q : UvPoly R F B) (œÅ : E ‚ü∂ F)
    (h : P.p = œÅ ‚â´ Q.p) : Q.functor ‚ü∂ P.functor :=
  let mv : Q.mvPoly.functor ‚ü∂ P.mvPoly.functor :=
    MvPoly.verticalNatTrans P.mvPoly Q.mvPoly œÅ (isTerminal.hom_ext ..) h (isTerminal.hom_ext ..)
  (toOverTerminal).whiskerLeft (Functor.whiskerRight mv fromOverTerminal)

open TwoSquare

/-- A cartesian map of polynomials
```
           œÜ
      E  -------->  E'
      |             |
  P.p |    (pb)     | P'.p
      v             v
      B  -------->  B'
            Œ¥
```
induces a natural transformation between their associated functors obtained by pasting the following
2-cells
```
             P'.p
C --- >  C/E' ----> C/B' -----> C
‚Äñ         |          |          ‚Äñ
‚Äñ   ‚Üó    | œÜ*  ‚âÖ    | Œ¥* ‚Üó    ‚Äñ
‚Äñ         v          v          ‚Äñ
C --- >  C/E -----> C/B  -----> C
              P.p
```
-/
def cartesianNatTrans {E' B' : C} (P : UvPoly R E B) (P' : UvPoly R E' B')
    (Œ¥ : B ‚ü∂ B') (œÜ : E ‚ü∂ E') (pb : IsPullback œÜ P.p P'.p Œ¥) : P.functor ‚ü∂ P'.functor :=
  let mv := P.mvPoly.cartesianNatTrans P'.mvPoly Œ¥ œÜ (isTerminal.hom_ext ..)
    pb (isTerminal.hom_ext ..)
  (toOverTerminal).whiskerLeft (Functor.whiskerRight mv fromOverTerminal)

open NatTrans in
theorem isCartesian_cartesianNatTrans {D F : C} (P : UvPoly R E B) (Q : UvPoly R F D)
    (Œ¥ : B ‚ü∂ D) (œÜ : E ‚ü∂ F) (pb : IsPullback œÜ P.p Q.p Œ¥) :
    (cartesianNatTrans P Q Œ¥ œÜ pb).IsCartesian := by
  apply IsCartesian.whiskerLeft
  apply IsCartesian.whiskerRight
  apply MvPoly.isCartesian_cartesianNatTrans

/-- A morphism from a polynomial `P` to a polynomial `Q` is a pair of morphisms `e : E ‚ü∂ E'`
and `b : B ‚ü∂ B'` such that the diagram
```
      E -- P.p ->  B
      ^            |
   œÅ  |            |
      |     œà      |
      Pb --------> B
      |            |
   œÜ  |            | Œ¥
      v            v
      F -- Q.p ->  D
```
is a pullback square. -/
structure Hom {F D : C} (P : UvPoly R E B) (Q : UvPoly R F D) where
  Pb : C
  Œ¥ : B ‚ü∂ D
  œÜ : Pb ‚ü∂ F
  œà : Pb ‚ü∂ B
  œÅ : Pb ‚ü∂ E
  is_pb : IsPullback œà œÜ Œ¥ Q.p
  w : œÅ ‚â´ P.p = œà

namespace Hom

open IsPullback

/-- The identity morphism in the category of polynomials. -/
def id (P : UvPoly R E B) : Hom P P := ‚ü®E, ùüô B, ùüô _ , P.p , ùüô _, IsPullback.of_id_snd, by simp‚ü©

end Hom

/-- The domain of the composition of two polynomial signatures.
See `UvPoly.comp`. -/
def compDom {E B E' B' : C} (P : UvPoly R E B) (P' : UvPoly R E' B') : C :=
  Limits.pullback (sndProj P B') P'.p

/--
The composition of two polynomial signatures. See `UvPoly.comp`.
Note that this is not just composition in the category `C`,
instead it is functor composition in the category `C ‚•§ C`,
meaning it satisfies `P.functor ‚ãô P'.functor ‚âÖ (comp P P').functor`.

   E' <---- compDom
   |           |
p' |   (pb)    |
   |           |
   V           V
   B' <-----   ‚Ä¢ -------> E
      sndProj  |          |
               |   (pb)   |p
               |          |
               V          V
             P @ B' -----> B
                    fstProj
-/
def comp {E B E' B' : C} (P : UvPoly R E B) (P' : UvPoly R E' B') :
    UvPoly R (compDom P P') (P @ B') where
  p := Limits.pullback.fst (sndProj P B') P'.p ‚â´ pullback.fst (fstProj P B') P.p
  morphismProperty := R.comp_mem _ _
   (R.of_isPullback (IsPullback.of_hasPullback (sndProj P B') P'.p).flip P'.morphismProperty)
   (R.of_isPullback (IsPullback.of_hasPullback (fstProj P B') P.p).flip P.morphismProperty)

namespace Equiv

variable {P : UvPoly R E B} {Œì X Y : C}

/-- Convert the morphism `pair` into a morphism in the over category `Over (ùü≠_ C)` -/
@[simp]
abbrev homMk (pair : Œì ‚ü∂ P @ X) : Over.mk (isTerminal.from Œì) ‚ü∂
    ((toOverTerminal ‚ãô MvPoly.functor P.mvPoly).obj X).toComma :=
  Over.homMk pair (isTerminal.hom_ext ..)

/--
A morphism `pair : Œì ‚ü∂ P @ X` is equivalent to a pair of morphisms
`fst : Œì ‚ü∂ B` and `snd : pb ‚ü∂ X` in the following diagram
```
    snd
B <---- pb ------> E
        |          |
        |          |p
        |          |
        V          V
        Œì -------> B
             fst
```
The following API allows users to convert back and forth along this (natural) bijection.
-/
def fst (pair : Œì ‚ü∂ P @ X) : Œì ‚ü∂ B :=
  (MvPoly.Equiv.fst (homMk pair)).hom

lemma fst_eq (pair : Œì ‚ü∂ P @ X) : fst pair = pair ‚â´ P.fstProj X := by
  aesop_cat

def snd (pair : Œì ‚ü∂ P @ X) : Limits.pullback (fst pair) P.p ‚ü∂ X :=
  (MvPoly.Equiv.snd (homMk pair)).left

lemma snd_eq (pair : Œì ‚ü∂ P @ X) : snd pair =
    Limits.pullback.map (fst pair) P.p (P.fstProj X) P.p pair (ùüô E) (ùüô B) (by simp [fst_eq])
    (by simp) ‚â´ sndProj P X := by
  simpa [Limits.pullback.map] using congrArg CommaMorphism.left (MvPoly.Equiv.snd_eq (homMk pair))

def snd' (pair : Œì ‚ü∂ P @ X) {pb f g} (H : IsPullback (P := pb) f g (fst pair) P.p) : pb ‚ü∂ X :=
  H.isoPullback.hom ‚â´ snd pair

theorem snd_eq_snd' (pair : Œì ‚ü∂ P @ X) : snd pair = snd' pair (.of_hasPullback ..) :=
  by simp [snd']

/-- Convert the morphism `x` into a morphism in the over category `Over (ùü≠_ C)` -/
@[simp]
abbrev mkAux (b : Œì ‚ü∂ B) (x : pullback b P.p ‚ü∂ X) :
    (PolynomialPartialAdjunction.leftAdjoint P.mvPoly.i.fst P.mvPoly.p).obj (Over.mk b) ‚ü∂
    ((toOverTerminal (R := R)).obj X).toComma :=
  Over.homMk x (isTerminal.hom_ext ..)

def mk (b : Œì ‚ü∂ B) (x : pullback b P.p ‚ü∂ X) : Œì ‚ü∂ P @ X :=
  (MvPoly.Equiv.mk (P := P.mvPoly) (Œì := Over.mk (isTerminal.from Œì))
    (Over.mk b) (by congr; apply isTerminal.hom_ext) (mkAux b x)).left

def mk' (b : Œì ‚ü∂ B) {pb f g} (H : IsPullback (P := pb) f g b P.p) (x : pb ‚ü∂ X) : Œì ‚ü∂ P @ X :=
  mk b (H.isoPullback.inv ‚â´ x)

theorem mk_eq_mk' (b : Œì ‚ü∂ B) (x : pullback b P.p ‚ü∂ X) :
    mk b x = mk' b (.of_hasPullback ..) x := by simp [mk']

@[simp]
lemma fst_mk (b : Œì ‚ü∂ B) (x : pullback b P.p ‚ü∂ X) :
    fst (mk b x) = b := by
  simp only [fst, mk, Over.homMk_eta]
  rw! (castMode := .all) [MvPoly.Equiv.fst_mk]
  simp [‚Üê heq_eq_eq]; rfl

@[simp]
lemma fst_mk' (b : Œì ‚ü∂ B) {pb f g} (H : IsPullback (P := pb) f g b P.p) (x : pb ‚ü∂ X) :
    fst (mk' b H x) = b := by
  simp [mk']

@[simp]
lemma mk'_comp_fstProj (b : Œì ‚ü∂ B) {pb f g} (H : IsPullback (P := pb) f g b P.p) (x : pb ‚ü∂ X) :
    mk' b H x ‚â´ P.fstProj X = b := by
  simp [‚Üê fst_eq]

theorem fst_comp_left (pair : Œì ‚ü∂ P @ X) {Œî} (f : Œî ‚ü∂ Œì) :
    fst (f ‚â´ pair) = f ‚â´ fst pair := by simp [fst_eq]

theorem fst_comp_right (pair : Œì ‚ü∂ P @ X) (f : X ‚ü∂ Y) :
    fst (pair ‚â´ P.functor.map f) = fst pair := by
  simp [fst_eq]

lemma snd'_eq (pair : Œì ‚ü∂ P @ X) {pb f g} (H : IsPullback (P := pb) f g (fst pair) P.p) :
    snd' pair H = pullback.lift (f ‚â´ pair) g (by simpa using H.w) ‚â´ sndProj P X := by
  rw [snd', snd_eq, ‚Üê Category.assoc]
  congr 1
  ext <;> simp

/-- Switch the selected pullback `pb` used in `UvPoly.Equiv.snd'` with a different pullback `pb'`. -/
lemma snd'_eq_snd' (pair : Œì ‚ü∂ P @ X) {pb f g} (H : IsPullback (P := pb) f g (fst pair) P.p)
    {pb' f' g'} (H' : IsPullback (P := pb') f' g' (fst pair) P.p) :
    snd' pair H = (H.isoIsPullback _ _ H').hom ‚â´ snd' pair H' := by
  simp [snd'_eq, ‚Üê Category.assoc]
  congr 2
  ext <;> simp

@[simp]
lemma snd_mk (b : Œì ‚ü∂ B) (x : pullback b P.p ‚ü∂ X) : snd (mk b x) =
    eqToHom (by simp) ‚â´ x := by
  have := MvPoly.Equiv.snd_mk (P := P.mvPoly) (Œì := Over.mk (isTerminal.from Œì))
    (Over.mk b) (by congr; apply isTerminal.hom_ext) (mkAux b x)
  convert congr_arg CommaMorphism.left this
  simp

@[simp]
lemma snd'_mk' (b : Œì ‚ü∂ B) {pb f g} (H : IsPullback (P := pb) f g b P.p) (x : pb ‚ü∂ X) :
    snd' (mk' b H x) (by rwa [fst_mk']) = x := by
  simp only [snd', mk', snd_mk]
  rw! [fst_mk]
  simp

@[simp]
lemma snd'_mk'' (b : Œì ‚ü∂ B) {pb f g} (H : IsPullback (P := pb) f g b P.p) (x : pb ‚ü∂ X)
   {pb' f' g'} (H' : IsPullback (P := pb') f' g' (fst (mk' b H x)) P.p := by exact H) :
    snd' (mk' b H x) H' = H.lift f' g' (by rw [fst_mk'] at H'; simp [H'.w]) ‚â´ x := by
  simp only [snd', mk', snd_mk]
  rw! [fst_mk]
  simp [‚Üê Category.assoc]
  congr 1
  apply H.hom_ext <;> simp


lemma snd_mk_heq (b : Œì ‚ü∂ B) (x : pullback b P.p ‚ü∂ X) :
    snd (mk b x) ‚âç x := by
  simp

theorem snd'_comp_left (pair : Œì ‚ü∂ P @ X)
    {pb f g} (H : IsPullback (P := pb) f g (fst pair) P.p)
    {Œî} (œÉ : Œî ‚ü∂ Œì)
    {pb' f' g'} (H' : IsPullback (P := pb') f' g' (œÉ ‚â´ fst pair) P.p) :
    snd' (œÉ ‚â´ pair) (by convert H'; rw [fst_comp_left]) =
    H.lift (f' ‚â´ œÉ) g' (by simp [H'.w]) ‚â´ snd' pair H := by
  simp only [snd'_eq, ‚Üê Category.assoc]
  congr 2
  ext
  ¬∑ simp
  ¬∑ simp

theorem snd'_comp_right (pair : Œì ‚ü∂ P @ X) (f : X ‚ü∂ Y)
    {pb f1 f2} (H : IsPullback (P := pb) f1 f2 (fst pair) P.p) :
    snd' (pair ‚â´ P.functor.map f) (by rwa [fst_comp_right]) =
    snd' pair H ‚â´ f := by
  simp only [snd'_eq, assoc]
  conv => right; rw [sndProj_comp, ‚Üê Category.assoc]
  congr 1
  ext <;> simp

theorem snd_comp_right (pair : Œì ‚ü∂ P @ X) (f : X ‚ü∂ Y) : snd (pair ‚â´ P.functor.map f) =
    eqToHom (by congr 1; apply fst_comp_right) ‚â´ snd pair ‚â´ f := by
  simp only [snd_eq, assoc, sndProj_comp]
  conv => right; simp only [‚Üê Category.assoc]
  congr 1
  have : fst (pair ‚â´ P.functor.map f) = fst pair := by simp [fst_eq]
  rw! [this]
  ext <;> simp

@[simp]
lemma eta (pair : Œì ‚ü∂ P @ X) :
    mk (fst pair) (snd pair) = pair := by
  have := MvPoly.Equiv.eta (P := P.mvPoly) (Œì := Over.mk (isTerminal.from Œì)) (homMk pair)
  exact congr_arg CommaMorphism.left this

@[simp]
lemma eta' (pair : Œì ‚ü∂ P @ X)
    {pb f1 f2} (H : IsPullback (P := pb) f1 f2 (fst pair) P.p) :
    mk' (fst pair) H (snd' pair H) = pair := by
  simp only [mk', snd']
  simp

lemma ext' {pair‚ÇÅ pair‚ÇÇ : Œì ‚ü∂ P @ X}
    {pb f g} (H : IsPullback (P := pb) f g (fst pair‚ÇÅ) P.p)
    (h1 : fst pair‚ÇÅ = fst pair‚ÇÇ)
    (h2 : snd' pair‚ÇÅ H = snd' pair‚ÇÇ (by rwa [h1] at H)) :
    pair‚ÇÅ = pair‚ÇÇ := by
  rw [‚Üê eta' pair‚ÇÅ H, ‚Üê eta' pair‚ÇÇ (by rwa [h1] at H), h2]
  rw! [h1]

/-- Switch the selected pullback `pb` used in `UvPoly.Equiv.mk'` with a different pullback `pb'`. -/
theorem mk'_eq_mk' (b : Œì ‚ü∂ B) {pb f g} (H : IsPullback (P := pb) f g b P.p) (x : pb ‚ü∂ X)
    {pb' f' g'} (H' : IsPullback (P := pb') f' g' b P.p) :
    mk' b H x = mk' b H' ((IsPullback.isoIsPullback _ _ H H').inv ‚â´ x) := by
  apply ext' (R := R) (f := f) (g := g) (by convert H; simp)
  ¬∑ have : ‚àÄ h, H'.lift f g h ‚â´ (IsPullback.isoIsPullback Œì E H H').inv = ùüô pb := by
      intro ; apply H.hom_ext <;> simp
    simp [‚Üê Category.assoc, this]
  ¬∑ simp

lemma mk'_comp_right (b : Œì ‚ü∂ B) {pb f1 f2} (H : IsPullback (P := pb) f1 f2 b P.p) (x : pb ‚ü∂ X)
    (f : X ‚ü∂ Y) : mk' b H x ‚â´ P.functor.map f = mk' b H (x ‚â´ f) := by
  refine .symm <| ext' (by rwa [fst_mk']) (by simp [fst_comp_right]) ?_
  rw [snd'_comp_right (H := by rwa [fst_mk'])]; simp

lemma mk_comp_right (b : Œì ‚ü∂ B) (x : pullback b P.p ‚ü∂ X) (f : X ‚ü∂ Y) :
    mk b x ‚â´ P.functor.map f = mk b (x ‚â´ f) := by
  simp [mk_eq_mk', mk'_comp_right]

theorem mk'_comp_left {Œî}
    (b : Œì ‚ü∂ B) {pb f g} (H : IsPullback f g b P.p) (x : pb ‚ü∂ X) (œÉ : Œî ‚ü∂ Œì)
    (œÉb) (eq : œÉ ‚â´ b = œÉb)
    {pb' f' g'} (H' : IsPullback (P := pb') f' g' œÉb P.p) :
    œÉ ‚â´ UvPoly.Equiv.mk' b H x = UvPoly.Equiv.mk' œÉb H'
    (H.lift (f' ‚â´ œÉ) g' (by simp [eq, H'.w]) ‚â´ x) := by
  apply ext' (f := f') (g := g') (H := by convert H'; simp [eq, fst_eq])
  ¬∑ rw [snd'_comp_left (H := by convert H; rw [fst_mk']) (H' := by convert H'; rw [‚Üê eq, fst_mk'])]
    simp
  ¬∑ simp [eq, fst_comp_left]

theorem mk_comp_left {Œî} (b : Œì ‚ü∂ B) (x : pullback b P.p ‚ü∂ X) (œÉ: Œî ‚ü∂ Œì) :
    œÉ ‚â´ UvPoly.Equiv.mk b x =
    UvPoly.Equiv.mk (œÉ ‚â´ b)
      (pullback.map _ _ _ _ œÉ (ùüô _) (ùüô _) (by simp) (by simp) ‚â´ x) := by
  simp only [mk_eq_mk']
  rw [mk'_comp_left (H := .of_hasPullback _ _) (H' := .of_hasPullback _ _) (eq := rfl)]
  congr 2; ext <;> simp

lemma mk'_comp_cartesianNatTrans_app {E' B' Œì X : C} {P' : UvPoly R E' B'}
    (y : Œì ‚ü∂ B) (pb f g) (H : IsPullback (P := pb) f g y P.p)
    (x : pb ‚ü∂ X) (e : E ‚ü∂ E') (b : B ‚ü∂ B')
    (hp : IsPullback P.p e b P'.p) :
    Equiv.mk' y H x ‚â´ (P.cartesianNatTrans P' b e hp.flip).app X =
    Equiv.mk' (y ‚â´ b) (H.paste_vert hp) x := by
  sorry
  -- have : fst (Equiv.mk' y H x ‚â´ (P.cartesianNatTrans P' b e hp.flip).app X) = y ‚â´ b := by
  --   rw [fst_eq, Category.assoc, cartesianNatTrans_fstProj, ‚Üê Category.assoc, mk'_comp_fstProj]
  -- refine ext' _ _ (this ‚ñ∏ H.paste_vert hp) (by simpa) ?_
  -- simp; rw [snd'_eq]
  -- have := snd'_mk' P X y H x
  -- rw [snd'_eq, ‚Üê fan_snd_map' _ _ X hp] at this
  -- refine .trans ?_ this
  -- simp only [‚Üê Category.assoc]; congr 1; ext <;> simp

end Equiv

namespace compDomEquiv

variable {Œì E B E' B' : C} {P : UvPoly R E B} {P' : UvPoly R E' B'}

/-
```
   Œì
   |
   |triple
   V
 compDom
   |‚üç
   |   ‚üç
   |      ‚üç
   V         ‚Üò
   ‚Ä¢ -------> E
   |          |
   |   (pb)   |p
   |          |
   V          V
P @ B' -----> B
       fstProj
```
This produces a map `fst : Œì ‚ü∂ E`,
and a map `(triple ‚â´ P.comp P').p : Œì ‚ü∂ P @ B'`,
which we can further break up using `UvPoly.Equiv.fst` and `UvPoly.Equiv.snd`.
```
  dependent
B <---- pb ------> E
        |          |
        |          |p
        |          |
        V          V
        Œì -------> B
            base
```
-/
def fst (triple : Œì ‚ü∂ compDom P P') : Œì ‚ü∂ E :=
  triple ‚â´ pullback.fst _ _ ‚â´ pullback.snd _ _

@[simp]
abbrev base (triple : Œì ‚ü∂ compDom P P') : Œì ‚ü∂ B := Equiv.fst (triple ‚â´ (P.comp P').p)

theorem fst_comp_p (triple : Œì ‚ü∂ compDom P P') :
    fst triple ‚â´ P.p = base triple := by
  simp [fst, Equiv.fst_eq, pullback.condition, comp]

abbrev dependent (triple : Œì ‚ü∂ compDom P P') {pb} (f : pb ‚ü∂ Œì) (g : pb ‚ü∂ E)
    (H : IsPullback f g (fst triple ‚â´ P.p) P.p) : pb ‚ü∂ B' :=
  Equiv.snd' (triple ‚â´ (P.comp P').p) (by convert H; simp only [fst_comp_p])

def snd (triple : Œì ‚ü∂ compDom P P') : Œì ‚ü∂ E' :=
  triple ‚â´ pullback.snd _ _

theorem snd_comp_p (triple : Œì ‚ü∂ compDom P P')
    {pb} (f : pb ‚ü∂ Œì) (g : pb ‚ü∂ E) (H : IsPullback f g (fst triple ‚â´ P.p) P.p) :
    snd triple ‚â´ P'.p =
    H.lift (ùüô Œì) (fst triple) (by simp) ‚â´ dependent triple f g H :=
  calc (triple ‚â´ pullback.snd _ _) ‚â´ P'.p
  _ = triple ‚â´ pullback.fst _ _ ‚â´ sndProj P B' := by
    simp [pullback.condition]
  _ = H.lift (ùüô Œì) (fst triple) (by simp) ‚â´ dependent triple f g H := by
    simp only [‚Üê assoc, dependent, comp, Equiv.snd'_eq]
    congr 1
    ext <;> simp [fst]

def mk (b : Œì ‚ü∂ B) (e : Œì ‚ü∂ E) (he : e ‚â´ P.p = b)
    {pb} (f : pb ‚ü∂ Œì) (g : pb ‚ü∂ E) (H : IsPullback f g b P.p)
    (b' : pb ‚ü∂ B') (e' : Œì ‚ü∂ E') (he' : e' ‚â´ P'.p = H.lift (ùüô Œì) e (by simp [he]) ‚â´ b') :
    Œì ‚ü∂ P.compDom P' :=
  pullback.lift (pullback.lift (Equiv.mk' b H b') e) e' (by
    have : b' = Equiv.snd' (Equiv.mk' b H b') (by convert H; simp) := by rw [Equiv.snd'_mk']
    conv => right; rw [he', this, Equiv.snd'_eq, ‚Üê Category.assoc]
    congr 1
    ext <;> simp )

lemma mk_comp (b : Œì ‚ü∂ B) (e : Œì ‚ü∂ E) (he : e ‚â´ P.p = b)
    {pb} (f : pb ‚ü∂ Œì) (g : pb ‚ü∂ E) (H : IsPullback f g b P.p)
    (b' : pb ‚ü∂ B') (e' : Œì ‚ü∂ E') (he' : e' ‚â´ P'.p = H.lift (ùüô Œì) e (by simp [he]) ‚â´ b') :
    mk b e he f g H b' e' he' ‚â´ (P.comp P').p = Equiv.mk' b H b' := by
  simp [mk, comp]

@[simp]
lemma base_mk (b : Œì ‚ü∂ B) (e : Œì ‚ü∂ E) (he : e ‚â´ P.p = b)
    {pb} (f : pb ‚ü∂ Œì) (g : pb ‚ü∂ E) (H : IsPullback f g b P.p)
    (b' : pb ‚ü∂ B') (e' : Œì ‚ü∂ E') (he' : e' ‚â´ P'.p = H.lift (ùüô Œì) e (by simp [he]) ‚â´ b') :
  base (mk b e he f g H b' e' he') = b := by simp [mk, comp]

@[simp]
lemma fst_mk (b : Œì ‚ü∂ B) (e : Œì ‚ü∂ E) (he : e ‚â´ P.p = b)
    {pb} (f : pb ‚ü∂ Œì) (g : pb ‚ü∂ E) (H : IsPullback f g b P.p)
    (b' : pb ‚ü∂ B') (e' : Œì ‚ü∂ E') (he' : e' ‚â´ P'.p = H.lift (ùüô Œì) e (by simp [he]) ‚â´ b') :
  fst (mk b e he f g H b' e' he') = e := by
  simp [mk, fst]

@[simp]
lemma dependent_mk (b : Œì ‚ü∂ B) (e : Œì ‚ü∂ E) (he : e ‚â´ P.p = b)
    {pb} (f : pb ‚ü∂ Œì) (g : pb ‚ü∂ E) (H : IsPullback f g b P.p)
    (b' : pb ‚ü∂ B') (e' : Œì ‚ü∂ E') (he' : e' ‚â´ P'.p = H.lift (ùüô Œì) e (by simp [he]) ‚â´ b')
    {pb'} (f' : pb' ‚ü∂ Œì) (g' : pb' ‚ü∂ E)
    (H' : IsPullback f' g' (fst (mk b e he f g H b' e' he') ‚â´ P.p) P.p) :
  dependent (mk b e he f g H b' e' he') f' g' H' = H.lift f' g' (by simp [‚Üê H'.w, he]) ‚â´ b' := by
  simp [mk, dependent, comp]

@[simp]
lemma snd_mk (b : Œì ‚ü∂ B) (e : Œì ‚ü∂ E) (he : e ‚â´ P.p = b)
    {pb} (f : pb ‚ü∂ Œì) (g : pb ‚ü∂ E) (H : IsPullback f g b P.p)
    (b' : pb ‚ü∂ B') (e' : Œì ‚ü∂ E') (he' : e' ‚â´ P'.p = H.lift (ùüô Œì) e (by simp [he]) ‚â´ b') :
  snd (mk b e he f g H b' e' he') = e' := by
  simp [mk, snd]

@[simp]
lemma eta (triple : Œì ‚ü∂ compDom P P') {pb} (f : pb ‚ü∂ Œì) (g : pb ‚ü∂ E)
    (H : IsPullback f g (base triple) P.p) (b' : pb ‚ü∂ B')
    (hbase' : b' = Equiv.snd' (triple ‚â´ (P.comp P').p) H) :
    mk (base triple) (fst triple) (fst_comp_p ..) f g H b' (snd triple) (by
      simp only [snd, assoc, ‚Üê pullback.condition, base, comp]
      simp only [hbase', Equiv.snd'_eq, ‚Üê Category.assoc]
      congr 1
      ext <;> simp [fst, comp]) = triple := by
  apply pullback.hom_ext
  ¬∑ ext
    ¬∑ simp [mk]
      conv => right; rw [‚Üê Equiv.eta'
        (triple ‚â´ pullback.fst (P.sndProj B') P'.p ‚â´ pullback.fst (P.fstProj B') P.p) H]
      congr
    ¬∑ simp [mk, fst]
  ¬∑ simp [mk, snd]

lemma ext (triple triple' : Œì ‚ü∂ compDom P P')
    (hfst : fst triple = fst triple')
    (hsnd : snd triple = snd triple')
    {pb} (f : pb ‚ü∂ Œì) (g : pb ‚ü∂ E)
    (H : IsPullback f g (fst triple ‚â´ P.p) P.p)
    (hd : dependent triple f g H = dependent triple' f g (by rwa [‚Üê hfst])) :
    triple = triple' := by
  rw [‚Üê eta triple f g (by convert H; simp [fst_comp_p]) (dependent triple f g H) rfl,
    ‚Üê eta triple' f g (by rwa [‚Üê fst_comp_p, ‚Üê hfst])
    (dependent triple' f g (by rwa [‚Üê hfst])) rfl]
  have : base triple = base triple' := by
    rw [‚Üê fst_comp_p, ‚Üê fst_comp_p, hfst]
  rw! [hsnd, hd, hfst, this]

lemma fst_comp {Œî} (œÉ : Œî ‚ü∂ Œì) (triple : Œì ‚ü∂ compDom P P') :
    fst (œÉ ‚â´ triple) = œÉ ‚â´ fst triple := by
  simp [fst]

lemma snd_comp {Œî} (œÉ : Œî ‚ü∂ Œì) (triple : Œì ‚ü∂ compDom P P') :
    snd (œÉ ‚â´ triple) = œÉ ‚â´ snd triple := by
  simp [snd]

lemma dependent_comp {Œî} (œÉ : Œî ‚ü∂ Œì) (triple : Œì ‚ü∂ compDom P P')
    {pb'} (f' : pb' ‚ü∂ Œì) (g' : pb' ‚ü∂ E) (H' : IsPullback f' g' (fst triple ‚â´ P.p) P.p)
    {pb} (f : pb ‚ü∂ Œî) (g : pb ‚ü∂ E) (H : IsPullback f g (fst (œÉ ‚â´ triple) ‚â´ P.p) P.p) :
    dependent (œÉ ‚â´ triple) f g H = H'.lift (f ‚â´ œÉ) g (by simp [‚Üê H.w, fst_comp]) ‚â´
    dependent triple f' g' H' := by
  simp only [dependent, comp, ‚Üê assoc, Equiv.snd'_eq]
  congr
  ext <;> simp

lemma comp_mk {Œî} (œÉ : Œî ‚ü∂ Œì) (b : Œì ‚ü∂ B) (e : Œì ‚ü∂ E) (he : e ‚â´ P.p = b)
    {pb'} (f' : pb' ‚ü∂ Œì) (g' : pb' ‚ü∂ E) (H' : IsPullback f' g' b P.p)
    {pb} (f : pb ‚ü∂ Œî) (g : pb ‚ü∂ E) (H : IsPullback f g (œÉ ‚â´ b) P.p)
    (b' : pb' ‚ü∂ B') (e' : Œì ‚ü∂ E') (he' : e' ‚â´ P'.p = H'.lift (ùüô Œì) e (by simp [he]) ‚â´ b') :
    œÉ ‚â´ mk b e he f' g' H' b' e' he' =
    mk (œÉ ‚â´ b) (œÉ ‚â´ e) (by simp [he]) f g H (H'.lift (f ‚â´ œÉ) g (by simp[‚Üê H.w]) ‚â´ b') (œÉ ‚â´ e')
    (by simp [he']; simp [‚Üê assoc]; congr 1; apply H'.hom_ext <;> simp) := by
  simp [mk]
  apply pullback.hom_ext
  ¬∑ apply pullback.hom_ext
    ¬∑ simp only [assoc, limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app]
      rw [Equiv.mk'_comp_left]
      rfl
    ¬∑ simp
  ¬∑ simp

end compDomEquiv

section

variable {E B F : C} (P : UvPoly R E B) (Q : UvPoly R F B) (œÅ : E ‚ü∂ F) (h : P.p = œÅ ‚â´ Q.p)

lemma fst_verticalNatTrans_app {Œì : C} (X : C) (pair : Œì ‚ü∂ Q @ X) :
    Equiv.fst (pair ‚â´ (verticalNatTrans P Q œÅ h).app X) = Equiv.fst pair := by
  dsimp [Equiv.fst]
  sorry

lemma snd'_verticalNatTrans_app {Œì : C} (X : C) (pair : Œì ‚ü∂ Q @ X) {R f g}
    (H : IsPullback (P := R) f g (Equiv.fst pair) Q.p) {R' f' g'}
    (H' : IsPullback (P := R') f' g' (Equiv.fst pair) P.p) :
    Equiv.snd' (pair ‚â´ (verticalNatTrans P Q œÅ h).app X) (by
      rw [‚Üê fst_verticalNatTrans_app] at H'
      exact H') =
    (H.lift f' (g' ‚â´ œÅ) (by simp [H'.w, h])) ‚â´
    Equiv.snd' pair H :=
  sorry

lemma mk'_comp_verticalNatTrans_app {Œì : C} (X : C) (b : Œì ‚ü∂ B) {R f g}
    (H : IsPullback (P := R) f g b Q.p) (x : R ‚ü∂ X) {R' f' g'}
    (H' : IsPullback (P := R') f' g' b P.p) :
    Equiv.mk' b H x ‚â´ (verticalNatTrans P Q œÅ h).app X = Equiv.mk'  b H'
    (H.lift f' (g' ‚â´ œÅ) (by simp [H'.w, h]) ‚â´ x) :=
  sorry

end


instance preservesPullbacks (P : UvPoly R E B) {Pb X Y Z : C} (fst : Pb ‚ü∂ X) (snd : Pb ‚ü∂ Y)
    (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (h: IsPullback fst snd f g) :
    IsPullback (P.functor.map fst) (P.functor.map snd) (P.functor.map f) (P.functor.map g) :=
  P.functor.map_isPullback h
