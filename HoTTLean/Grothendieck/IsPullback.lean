import Mathlib.CategoryTheory.Limits.Yoneda
import Mathlib.CategoryTheory.Limits.Preserves.Finite
import Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq

import HoTTLean.Pointed.Basic
import HoTTLean.ForMathlib
import HoTTLean.ForMathlib.CategoryTheory.Functor.IsPullback

universe v u v‚ÇÅ u‚ÇÅ v‚ÇÇ u‚ÇÇ v‚ÇÉ u‚ÇÉ

namespace CategoryTheory

namespace Functor.Grothendieck

open Functor.IsPullback

section


variable {Œì : Type u} [Category.{v} Œì] {A : Œì ‚•§ Cat.{v‚ÇÅ,u‚ÇÅ}}

variable (A)

def toPCat : ‚à´ A ‚•§ PCat.{v‚ÇÅ,u‚ÇÅ} :=
  functorTo (forget _ ‚ãô A) (fun x => x.fiber) (fun f => f.fiber)
    (by simp) (by intros; simp)

@[simp] theorem toPCat_obj_base (x) :
    ((toPCat A).obj x).base = A.obj x.base := by
  rfl

@[simp] theorem toPCat_obj_fiber (x) :
    ((toPCat A).obj x).fiber = x.fiber := by
  rfl

@[simp] theorem toPCat_map_base {x y} (f : x ‚ü∂ y) :
    ((toPCat A).map f).base = A.map f.base := by
  rfl

@[simp] theorem toPCat_map_fiber {x y} (f : x ‚ü∂ y) :
    ((toPCat A).map f).fiber = f.fiber := by
  rfl

-- formerly duplicated as `toPCat_comp_forgetPoint` and `comm_sq`
theorem toPCat_forgetToCat : toPCat A ‚ãô PCat.forgetToCat
  = Grothendieck.forget A ‚ãô A :=
  rfl

namespace IsPullback

variable {C : Type*} [Category C]
  (fst : C ‚•§ PCat.{v‚ÇÅ, u‚ÇÅ})
  (snd : C ‚•§ Œì)
  (w : fst ‚ãô PCat.forgetToCat = snd ‚ãô A)

abbrev pt (x : C) := (fst.obj x).fiber

abbrev point {x y : C} (f : x ‚ü∂ y) :
    (fst.map f)‚ü±.obj (pt fst x) ‚ü∂ pt fst y :=
  (fst.map f).fiber

variable {A} {fst} {snd}

@[simp] def liftObjFiber (x : C) : A.obj (snd.obj x) :=
  ((eqToHom w).app x).obj (pt fst x)

variable {x y : C} (f : x ‚ü∂ y)

@[simp] def liftMapFiber : ((snd ‚ãô A).map f).obj (liftObjFiber w x) ‚ü∂ liftObjFiber w y :=
  let m1 := ((eqToHom w).app y).map (point fst f)
  let m2 := (eqToHom ((eqToHom w).naturality f).symm).app
    (pt fst x)
  m2 ‚â´ m1

theorem liftMapFiber_id (x : C) : liftMapFiber w (ùüô x) = eqToHom (by simp) := by
  simp [eqToHom_map]

theorem liftMapFiber_comp {x y z} (f : x ‚ü∂ y) (g : y ‚ü∂ z) :
    liftMapFiber w (f ‚â´ g) =
    eqToHom (by simp)
    ‚â´ (A.map (snd.map g)).map (liftMapFiber w f)
    ‚â´ liftMapFiber w g := by
  have hgNatNatF := (eqToHom ((eqToHom w).naturality g).symm).naturality (fst.map f).fiber
  have h := congr_arg (Œª x ‚Ü¶ x ‚â´ ((eqToHom w).app z).map (fst.map g).fiber) hgNatNatF
  dsimp at h
  simp only [Category.assoc, eqToHom_app ((eqToHom w).naturality g).symm] at h
  simp [eqToHom_map, h]

variable (fst) (snd)

def lift : C ‚•§ Grothendieck A := functorTo snd
    (liftObjFiber w)
    (liftMapFiber w)
    (liftMapFiber_id w)
    (liftMapFiber_comp w)

@[simp] theorem lift_obj_base (x) :
    ((lift fst snd w).obj x).base = snd.obj x := by
  simp [lift]

@[simp] theorem lift_obj_fiber (x) :
    ((lift fst snd w).obj x).fiber = liftObjFiber w x := by
  simp [lift]

@[simp] theorem lift_map_base {x y} (f : x ‚ü∂ y) :
    ((lift fst snd w).map f).base = snd.map f := by
  simp [lift]

@[simp] theorem lift_map_fiber {x y} (f : x ‚ü∂ y) :
    ((lift fst snd w).map f).fiber = liftMapFiber w f := by
  simp [lift]

@[simp] theorem fac_right : lift fst snd w ‚ãô Grothendieck.forget A = snd := by
  apply CategoryTheory.Functor.ext
  ¬∑ simp
  ¬∑ simp

@[simp] theorem fac_left : lift fst snd w ‚ãô Grothendieck.toPCat A = fst := by
  apply CategoryTheory.Functor.ext
  ¬∑ intro x y f
    apply Grothendieck.Hom.ext
    ¬∑ simp [eqToHom_map, PCat.eqToHom_base_map,
        Functor.congr_hom (eqToHom_app w y) (point fst f)]
    ¬∑ have h := Functor.congr_hom w f
      simp only [PCat.forgetToCat_map, Functor.comp_map] at h
      simp [h]
  ¬∑ intro x
    have h := (Functor.congr_obj w x).symm
    simp only [Functor.comp_obj, forget_obj] at h
    fapply hext
    ¬∑ simp [h]
    ¬∑ simp [Cat.eqToHom_obj]

theorem lift_uniq (m : C ‚•§ Grothendieck A)
    (hl : m ‚ãô Grothendieck.toPCat A = fst)
    (hr : m ‚ãô Grothendieck.forget A = snd) :
    m = lift _ _ w := by
  apply Grothendieck.FunctorTo.hext
  ¬∑ rw [hr, fac_right]
  ¬∑ aesop
  ¬∑ aesop

theorem hom_ext {m n : C ‚•§ Grothendieck A}
    (hl : m ‚ãô Grothendieck.toPCat A = n ‚ãô Grothendieck.toPCat A)
    (hr : m ‚ãô Grothendieck.forget A = n ‚ãô Grothendieck.forget A) :
    m = n := by
  rw [lift_uniq (m ‚ãô toPCat A) (m ‚ãô forget A) ?_ m rfl rfl,
    lift_uniq (n ‚ãô toPCat A) (n ‚ãô forget A) ?_ n rfl rfl]
  rw! [hl, hr]
  . show n ‚ãô (toPCat A ‚ãô PCat.forgetToCat) = _
    rw [toPCat_forgetToCat, Functor.assoc]
  . show m ‚ãô (toPCat A ‚ãô PCat.forgetToCat) = _
    rw [toPCat_forgetToCat, Functor.assoc]

def aux {C : Type*} [inst : Category C] (Cn : C ‚•§ PCat) (Cw : C ‚•§ Œì)
    (hC : Cn ‚ãô forget (ùü≠ Cat) = Cw ‚ãô A) :
    (lift : C ‚•§ Grothendieck A) √ó'
    lift ‚ãô toPCat A = Cn ‚àß
    lift ‚ãô forget A = Cw ‚àß
    ‚àÄ {l0 l1 : C ‚•§ Grothendieck A}, l0 ‚ãô toPCat A = l1 ‚ãô toPCat A ‚Üí
    l0 ‚ãô forget A = l1 ‚ãô forget A ‚Üí l0 = l1 :=
  ‚ü® lift Cn Cw hC, fac_left _ _ _, fac_right _ _ _, hom_ext ‚ü©

end IsPullback

open IsPullback

/--
The following square is a (meta-theoretic) pullback of functors
  Grothendieck A --- toPCat ----> PCat
        |                           |
        |                           |
 Grothendieck.forget        PCat.forgetToCat
        |                           |
        v                           v
        Œì--------------A---------> Cat
-/
def isPullback : Functor.IsPullback (toPCat A) (forget _) (forget _) A :=
  ofUniversal (toPCat A) (forget _) (forget _) A (toPCat_forgetToCat _)
  (fun Cn Cw hC => aux Cn Cw hC)
  (fun Cn Cw hC => aux Cn Cw hC)

end

-- TODO verify that the rest of this file is no longer needed
-- /-
-- In this section we build the lemmas for showing the pullback

--   Grothendieck A --- toPCat ----> PCat
--         |                           |
--         |                           |
--  Grothendieck.forget        PCat.forgetToCat
--         |                           |
--         v                           v
--         Œì--------------A---------> Cat
-- in the appropriately sized category `Cat.{v, max u (v+1)}`;
-- where `(Œì : Type u) [Category.{v} Œì] (A : Œì ‚•§ Cat.{v,v})`.

-- This particular choice of hom universe level avoids using ULiftHom.
-- In our applications either `u = v` for a small `Œì`
-- so that `A : Œì ‚•§ Cat.{u,u}`,
-- or `Œì = Grpd.{v,v}` and `A : Grpd.{v,v} ‚•§ Cat.{v,v}` is the inclusion
-- so that `u = v + 1`.
-- -/
-- namespace IsPullback

-- variable (Œì : Type u) [Category.{v} Œì] (A : Œì ‚•§ Cat.{v,v})

-- open Functor ULift

-- variable {Œì}

-- abbrev uLiftGrothendieck : Cat.{v, max u (v+1)} :=
--   Cat.ofULift.{max u (v+1)} (Grothendieck A)

-- abbrev uLiftGrothendieckForget :
--     uLiftGrothendieck.{v,u} A ‚ü∂ Cat.ofULift.{v+1} Œì :=
--   downFunctor ‚ãô Grothendieck.forget A ‚ãô upFunctor

-- abbrev uLiftCat : Cat.{v, max u (v+1)} :=
--   Cat.ofULift.{max u (v+1)} Cat.{v,v}

-- abbrev uLiftPCat : Cat.{v, max u (v+1)} :=
--   Cat.ofULift.{max u (v+1)} PCat.{v,v}

-- abbrev uLiftPCatForgetToCat : uLiftPCat.{v,u} ‚ü∂ uLiftCat.{v,u} :=
--   downFunctor ‚ãô PCat.forgetToCat ‚ãô upFunctor

-- abbrev uLiftToPCat : uLiftGrothendieck.{v,u} A ‚ü∂ uLiftPCat.{v,u} :=
--   ULift.downFunctor ‚ãô Grothendieck.toPCat A ‚ãô ULift.upFunctor

-- abbrev uLiftA : Cat.ofULift.{v+1} Œì ‚•§ uLiftCat.{v,u} :=
--   downFunctor ‚ãô A ‚ãô upFunctor

-- variable {A}

-- theorem comm_sq : uLiftToPCat A ‚â´ uLiftPCatForgetToCat
--     = uLiftGrothendieckForget A ‚â´ uLiftA A := by
--   apply CategoryTheory.Functor.ext
--   ¬∑ intro X Y f
--     rfl
--   ¬∑ intro
--     rfl

-- variable (A)

-- open Limits PullbackCone

-- def cone : Limits.PullbackCone uLiftPCatForgetToCat (uLiftA A)
--   := Limits.PullbackCone.mk (uLiftToPCat A) (uLiftGrothendieckForget A) comm_sq

-- variable {A}

-- abbrev pt' {s : PullbackCone uLiftPCatForgetToCat (uLiftA A)}
--     (x : s.pt) := (downFunctor.obj (s.fst.obj x)).fiber

-- theorem condition' {s : PullbackCone uLiftPCatForgetToCat (uLiftA A)} :
--     s.fst ‚ãô downFunctor ‚ãô PCat.forgetToCat = s.snd ‚ãô downFunctor ‚ãô A := by
--   rw [‚Üê comp_upFunctor_inj.{_,_,_,_,max u (v + 1)}]
--   exact s.condition

-- variable {s : PullbackCone uLiftPCatForgetToCat.{v,u} (uLiftA.{v,u} A)} {x y : s.pt} {f : x ‚ü∂ y}

-- def lift (s : PullbackCone uLiftPCatForgetToCat.{v,u} (uLiftA.{v,u} A)) :
--     s.pt ‚•§ Grothendieck A :=
--   IsMegaPullback.lift
--     (s.fst ‚ãô downFunctor)
--     (s.snd ‚ãô downFunctor)
--     condition'

-- def lift' (s : PullbackCone uLiftPCatForgetToCat (uLiftA A)) :
--     s.pt ‚ü∂ uLiftGrothendieck A := (lift s) ‚ãô ULift.upFunctor

-- theorem fac_left (s : PullbackCone uLiftPCatForgetToCat (uLiftA A)) :
--     lift s ‚ãô Grothendieck.toPCat A ‚ãô upFunctor = s.fst := by
--   rw [‚Üê comp_downFunctor_inj]
--   exact IsMegaPullback.fac_left
--     (s.fst ‚ãô downFunctor)
--     (s.snd ‚ãô downFunctor)
--     condition'

-- theorem fac_right (s : PullbackCone uLiftPCatForgetToCat (uLiftA A)) :
--     lift s ‚ãô Grothendieck.forget A ‚ãô upFunctor
--     = s.snd := by
--   rw [‚Üê comp_downFunctor_inj]
--   exact IsMegaPullback.fac_right
--     (s.fst ‚ãô downFunctor)
--     (s.snd ‚ãô downFunctor)
--     condition'

-- theorem lift_uniq (s : PullbackCone uLiftPCatForgetToCat.{v,u} (uLiftA.{v,u} A)) (m : s.pt ‚•§ Grothendieck A)
--     (hl : m ‚ãô Grothendieck.toPCat A = s.fst ‚ãô downFunctor)
--     (hr : m ‚ãô Grothendieck.forget A = s.snd ‚ãô downFunctor) :
--     m = lift s :=
--   IsMegaPullback.lift_uniq
--     (s.fst ‚ãô downFunctor) (s.snd ‚ãô downFunctor) condition' m hl hr

-- theorem lift_uniq' (s : PullbackCone uLiftPCatForgetToCat.{v,u} (uLiftA.{v,u} A)) (m : s.pt ‚ü∂ uLiftGrothendieck A)
--     (hl : m ‚â´ uLiftToPCat A = s.fst) (hr : m ‚â´ uLiftGrothendieckForget A = s.snd) :
--     m = lift' s := by
--   unfold lift'
--   rw [‚Üê lift_uniq s (m ‚ãô downFunctor) (congr_arg (Œª F ‚Ü¶ F ‚ãô downFunctor) hl)
--     (by
--       simp only [Cat.of_Œ±, Functor.assoc, ‚Üê hr, uLiftGrothendieckForget, Cat.comp_eq_comp]
--       rfl)]
--   aesop_cat

-- variable (A)

-- def isLimit : IsLimit (cone A) :=
--   IsLimit.mk comm_sq lift' fac_left fac_right lift_uniq'

-- end IsPullback

-- open IsPullback

-- /-
-- The following square is a pullback

--   Grothendieck A --- toPCat ----> PCat
--         |                           |
--         |                           |
--  Grothendieck.forget        PCat.forgetToCat
--         |                           |
--         v                           v
--         Œì--------------A---------> Cat
-- in the appropriately sized category `Cat.{v, max u (v+1)}`;
-- where `(Œì : Type u) [Category.{v} Œì] (A : Œì ‚•§ Cat.{v,v})`.

-- This particular choice of hom universe level avoids using ULiftHom.
-- In our applications either `u = v` for a small `Œì`
-- so that `A : Œì ‚•§ Cat.{u,u}`,
-- or `Œì = Grpd.{v,v}` and `A : Grpd.{v,v} ‚•§ Cat.{v,v}` is the inclusion
-- so that `u = v + 1`.
-- -/
-- theorem isPullback {Œì : Type u} [Category.{v} Œì] (A : Œì ‚•§ Cat.{v,v}) :
--     IsPullback
--       (uLiftToPCat A)
--       (uLiftGrothendieckForget A)
--       (uLiftPCatForgetToCat)
--       (uLiftA A) :=
--   IsPullback.of_isLimit (isLimit A)

end Functor.Grothendieck

end CategoryTheory
